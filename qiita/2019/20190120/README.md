

# はじめに

去年頃から`Elixir`という言語に興味を持ち、本を買って実際にコーディングをしたのでその内容を振り返りながらまとめてみます。


読んだ本[プログラミングElixir](https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0Elixir-Dave-Thomas/dp/4274219151/ref=sr_1_1?ie=UTF8&qid=1547916717&sr=8-1&keywords=elixir+programming)の練習問題を参考に`Elixir`の言語の特徴とかを自分なりにまとめてみます。

今回は、その中でも`Elixir`の初歩の初歩、`パターンマッチ`について考えてみます。


# 代入という概念は無い

今まで書いてきたプログラミング言語(Java, pythonなど)は書き方は違えど変数に値を代入して、その変数に処理を行ったりすることでプログラミングをしてきました。

例えば、`Java`なら

```example.java
int i = 10;
```

こんな感じで、`python`なら

```example.py
i = 10
```

といった感じでしょうか？

一方で、`Elixir`でも`=`を使うのですが、代入という意味ではなく、`assersion（表明）`ということ（らしい）です。実際にコードで書いてみると、下のようになります。


```example.exs
i = 10
```

この例だけを見ると、
「いやいや`python`と一緒やんけｗｗｗ」
と思ったそこのあなた、**私もそう思いました。**

ただ、本を読み進めていくうちに、
「パターンマッチつよｗｗｗ」
とか
「関数の呼び出しに最適すぎる」
とか
「えっ、`if文`書かなくても条件分岐できるのか！！！」
と狂喜乱舞してました。

何が言いたいかというと、自分が持っていた**従来のプログラミングにおける等号(=)の概念をパターンマッチは一変させた**ということです。

先述した例だけだと、`パターンマッチ`が何なのか、まだ説明しきれてないので、これから少しだけ説明していきます。

## `i = 10`で変数を`束縛`するということ

さきほどの例では左辺の変数`i`を整数`10`に`束縛`していました。
`束縛`という表現に違和感を覚えるかもしれませんが、自分は「変数`i`を`10`という整数値に固定した」というふうに考えました。

さてここで

```example.exs
10 = i
```

を考えてみます。どうなると思いますか？

これは`10 = i`という`パターンマッチ`が行われた結果、エラーは起きずパス（成功）します。`Elixir`の対話環境で行った結果は以下の通りで

```examle.exs
# 変数iを10に束縛
iex(1)> i = 10
10
# パターンマッチを実施
iex(2)> 10 = i
10
```

成功していることが分かります。
では次に、

```example.exs
5 = i
```

を考えてみます。特に何も起きないかと思いきや、エラーが起きてしまいます。

```example.exs
# パターンマッチを実施
iex(3)> 5 = i
** (MatchError) no match of right hand side value: 10
```

これは、右辺にある変数`i`が、`iex(1)> i = 10`で整数`10`に束縛され、
`iex(3)> 5 = i`では`5 = 10`と評価されているためです。当然`5`と`10`は全く異なるのでエラーが出力されてしまいます。

ただ、ここまで聞いても
「だから何がすごいのだろう？」
と思ったそこのあなた、**私もそう(ry**

今までは変数は1つでした。
では、複数の変数に対して`束縛`を行い、複数の値に対してパターンマッチを行いたいと思います。

## リストを考えてみる

当然、`Elixir`にもリストはあります。
具体的には以下のように書きます

```example.exs
list = [1, 2, 3, 4]
```

これは、`list`という変数に対して`[1, 2, 3, 4]`という値を`束縛`した例です。
まずは、先程の`i`の場合と同じことを対話環境で実行してみます。

```example.exs
iex(1)> list = [1,2,3,4]
[1, 2, 3, 4]
iex(2)> [1,2,3,4] = list
[1, 2, 3, 4]
iex(3)> [1,2,3,5] = list
** (MatchError) no match of right hand side value: [1, 2, 3, 4]
```

何が起きているかわかりますか？
`iex(1)`では`list`を`[1,2,3,4]`という値に`束縛`しています。

`iex(2)`ではリスト`[1,2,3,4]`を`list`とパターンマッチをし、リストの内容が一致してるので成功しています。

対して、`iex(3)`では、リスト`[1,2,3,5]`と`list`に束縛した値は異なるので、パターンマッチした結果エラーが起きています。

また、`[1,3,4,5]`などの値と変数`list`でパターンマッチを行っても当然エラーが出力されます。

ここまで、読んでみて
「変数`i`の場合と何か変わった？」
と思っ(ry

## えっ？これだけ？

ここまで見てきて、
「`パターンマッチ`ってこれだけなの？」
と思うと思います。
もちろん、説明すべき`^(ピン演算子)`や`_(アンダースコア)`などの`パターンマッチ`における重要な記法はありますが、ここで重要なのは今まで説明してきたことが全てだと思います。


具体的には**パターンマッチは、左辺と右辺の値を同じにする方法を探し、同じになる方法が見つかれば成功とし、そうでなければエラーとして処理する**ということです。

今はまだ、具体例が無いので「えっ？これだけ？」と思うと思いますが。。。


# おわりに

さて、ここまで簡単ではありますが、`Elixir`の`パターンマッチ`について、まとめてみました（とはいえ[プログラミングElixir](https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0Elixir-Dave-Thomas/dp/4274219151/ref=sr_1_1?ie=UTF8&qid=1547916717&sr=8-1&keywords=elixir+programming)の2章の内容を薄くしただけ感が半端ないですが。。。）。

分量もそこそこになってしまったので、一旦ここでこの記事は終わりたいと思います。

最初この記事を書き始めたときは、`Elixir`で書いたプログラムを基に、中身の説明を行う予定でした。しかし、「 **`パターンマッチ`ってめっちゃ重要だよな？** 」と思い、単発で書いてしまいした。

次回は、今回でてきた`パターンマッチ`を関数に組み込んだときのことについて説明していきたいと思います。
`パターンマッチ`がその威力を発揮するのはこの関数での呼び出しのとき！と現時点の私は思っています。
また、今回は説明できなかった`^`と`_`の使い方と威力についても説明できたらなと思います。

それでは、最後まで読んでいただきありがとうございました。

# 参考文献

* 著書：[プログラミングElixir](https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0Elixir-Dave-Thomas/dp/4274219151/ref=sr_1_1?ie=UTF8&qid=1547916717&sr=8-1&keywords=elixir+programming)
